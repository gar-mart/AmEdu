using System;
using System.Threading.Tasks;

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;

using Repository.Infrastructure;

using Xunit;

namespace AutomatedTests;

public abstract class BaseFixture: IAsyncLifetime, IDisposable
{
    private static readonly Random _random = new();

    /// <summary>
    /// Global <see cref="IConfiguration"/> object that can be used for setup.
    /// </summary>
    public IConfiguration Configuration { get; }
    public AppConfigurations AppConfigurations { get; }
    public TestingRepository TestingRepository { get; }
    /// <summary>
    /// The testing project's user context. This user is generated by default in Testing.GenerateDefaultData.
    /// </summary>
    /// <remarks>
    /// We are hardcoding these values based on the aforementioned SQL procedure.
    /// </remarks>
    public TestUserContext UserContext { get; } = new TestUserContext
    {
        UserId = 1,
        Email = "admin@freedomdev.com",
        TimeZoneId = "Eastern Standard Time"
    };

    /// <summary>
    /// Defines Setup logic that should be run before each class suite of tests.
    /// </summary>
    public BaseFixture(TestingRepository testingRepository, IOptions<AppConfigurations> appConfigurations)
    {
        TestingRepository = testingRepository;
        AppConfigurations = appConfigurations.Value;
    }

    /// <summary>
    /// Defines Teardown logic that should be run after each class suite of tests.
    /// </summary>
    public virtual void Dispose()
    {
        GC.SuppressFinalize(this);
    }

    /// <summary>
    /// Defines Setup logic that should be run before each class suite of tests.
    /// </summary>
    /// <returns></returns>
    public virtual Task InitializeAsync()
    {
        return Task.CompletedTask;
    }

    /// <summary>
    /// Defines Teardown logic that should be run after each class suite of tests.
    /// </summary>
    /// <returns></returns>
    public virtual Task DisposeAsync()
    {
        return Task.CompletedTask;
    }

    public ILogger<T> StubLogger<T>()
    {
        return NullLoggerFactory.Instance.CreateLogger<T>();
    }
}
